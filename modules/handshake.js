/**
 * @file handshake.js
 * @brief Defines HandshakeManager for managing AU1/AU2 key exchanges and session key derivation in ETCS.
 *
 * The class encapsulates:
 * - Dynamic key generation (K1, K2, K3)
 * - AU1 (OBU → RBC) message construction
 * - AU2 (RBC → OBU) message with MAC generation
 * - Session key derivation using SHA256 and ETCS state constraints
 */

import { ETCS_STATES } from './etcs_states.js';

export class HandshakeManager {

  /**
   * @brief Generate three random 64-bit session keys (K1, K2, K3)
   * @returns {Object}
   * @variable K1 - First dynamic session key (Uint8Array of 8 bytes)
   * @variable K2 - Second session key
   * @variable K3 - Third session key
   */
  static generateDynamicKeys() {
    return {
      K1: Array.from(crypto.getRandomValues(new Uint8Array(8))),
      K2: Array.from(crypto.getRandomValues(new Uint8Array(8))),
      K3: Array.from(crypto.getRandomValues(new Uint8Array(8)))
    };
  }

  /**
   * @brief Generate the AU1 authentication message from OBU to RBC
   * @param obuId - @variable ETCS_ID of OBU (e.g., "OBU1234")
   * @param rbcId - @variable RBC ID to target (e.g., "DE0001")
   * @param randomValues - @variable Two-part random nonce generated by OBU
   * @param keys - @variable { K1, K2, K3 } dynamic session keys
   * @param stateManager - @variable ETCS state machine instance
   * @returns {Object} AU1 message
   */
  static generateAU1(obuId, rbcId, randomValues, keys, stateManager) {
    const currentState = stateManager.getCurrentState();
    if (![ETCS_STATES.DISCONNECTED.id, ETCS_STATES.READY.id].includes(currentState.id)) {
      throw new Error(`Cannot initiate handshake from state ${currentState.name}`);
    }

    return {
      type: "AU1",
      ETCS_ID: obuId,                       // @variable ID of originating OBU
      DF: 1,                                // @variable Direction Flag
      MTI: "AU1",                           // @variable Message Type Indicator
      Destination_ID: `RBC-${rbcId}`,       // @variable Target RBC ID
      SaF: 32,                              // @variable Security attribute flag
      Random_RB_L: randomValues[0],         // @variable Random left 32-bit
      Random_RB_R: randomValues[1],         // @variable Random right 32-bit
      K1: keys.K1,
      K2: keys.K2,
      K3: keys.K3,
      timestamp: Date.now(),
      SEQUENCE: Math.floor(Math.random() * 1e6),
      protocol_state: ETCS_STATES.HANDSHAKE_INITIATED.id
    };
  }

  /**
   * @brief Generate AU2 authentication message in response to AU1
   * @param rbcId - @variable ID of the responding RBC
   * @param direction - @variable Direction flag (0 or 1)
   * @param au1 - @variable AU1 message object
   * @param randomValues - @variable Generated randoms from RBC
   * @param K1, K2, K3 - @variable Keys used for MAC generation
   * @param stateManager - @variable State manager instance
   * @returns {Object} AU2 message
   */
  static generateAU2(rbcId, direction, au1, randomValues, K1, K2, K3, stateManager) {
    if (stateManager.getCurrentState().id !== ETCS_STATES.HANDSHAKE_INITIATED.id) {
      throw new Error("Invalid state for AU2 generation");
    }

    const mac = this.computeAu2Mac({
      RAL: randomValues.Random_RA_L,
      RAR: randomValues.Random_RA_R,
      RBL: au1.Random_RB_L,
      RBR: au1.Random_RB_R,
      DF: direction,
      MTI: 0x01,
      ETCS_ID: au1.ETCS_ID,
      Destination_ID: rbcId,
      protocol_state: ETCS_STATES.VERSION_EXCHANGED.id
    }, K1, K2, K3);

    return {
      type: "AU2",
      ETCS_ID: rbcId,                        // @variable Source: RBC
      DF: direction,                         // @variable Direction flag
      MTI: "AU2",
      Destination_ID: au1.ETCS_ID,
      SaF: au1.SaF || 0x20,
      Random_RA_L: randomValues.Random_RA_L,
      Random_RA_R: randomValues.Random_RA_R,
      MAC: mac,
      timestamp: Date.now(),
      SEQUENCE: Math.floor(Math.random() * 1e6),
      protocol_state: ETCS_STATES.VERSION_EXCHANGED.id
    };
  }

  /**
   * @brief Compute MAC for AU2 message using AES-CBC
   * @returns {String} MAC string (hex)
   */
  static computeAu2Mac(params, K1, K2, K3) {
    const buffer = new Uint8Array(24);
    const view = new DataView(buffer.buffer);

    view.setUint32(0, params.RAL);
    view.setUint32(4, params.RAR);
    view.setUint32(8, params.RBL);
    view.setUint32(12, params.RBR);
    view.setUint32(16, params.protocol_state);

    buffer[20] = (params.DF << 1) | (params.MTI & 0x1);
    buffer[21] = buffer[22] = buffer[23] = 0;

    return this.aesMac(buffer, [K1, K2, K3]);
  }

  /**
   * @brief AES-CBC MAC computation using 3 combined keys
   * @returns {String} Last 16 chars of AES ciphertext as MAC
   */
  static aesMac(input, keys) {
    const combinedKey = new Uint8Array([...keys[0], ...keys[1], ...keys[2]]);
    const key = CryptoJS.lib.WordArray.create(combinedKey);
    const data = CryptoJS.lib.WordArray.create(input);
    const iv = CryptoJS.lib.WordArray.create(new Uint8Array(16)); // zeroed IV

    const encrypted = CryptoJS.AES.encrypt(data, key, {
      iv,
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.NoPadding
    });

    return encrypted.ciphertext.toString().slice(-16);
  }

  /**
   * @brief Derives secure session keys from randoms + initial keys
   * @returns {Object}
   * @variable ks1 - Session key 1 derived using SHA256
   * @variable ks2 - Session key 2
   * @variable ks3 - Session key 3
   */
  static deriveSessionKeys(RA, RB, K1, K2, K3, stateManager) {
    if (stateManager.getCurrentState().id !== ETCS_STATES.VERSION_EXCHANGED.id) {
      throw new Error("Invalid state for key derivation");
    }

    const toWordArray = (val) => {
      if (Array.isArray(val)) return CryptoJS.lib.WordArray.create(new Uint8Array(val));
      const view = new DataView(new ArrayBuffer(4));
      view.setUint32(0, val, false);
      return CryptoJS.lib.WordArray.create(new Uint8Array(view.buffer));
    };

    const RA_L = toWordArray(RA.Random_RA_L);
    const RA_R = toWordArray(RA.Random_RA_R);
    const RB_L = toWordArray(RB.Random_RB_L);
    const RB_R = toWordArray(RB.Random_RB_R);
    const k1 = toWordArray(K1);
    const k2 = toWordArray(K2);
    const k3 = toWordArray(K3);

    const ks1 = CryptoJS.SHA256(RA_L.concat(RB_L).concat(k1)).toString(CryptoJS.enc.Hex).slice(0, 16);
    const ks2 = CryptoJS.SHA256(RA_R.concat(RB_R).concat(k2)).toString(CryptoJS.enc.Hex).slice(0, 16);
    const ks3 = CryptoJS.SHA256(RA_L.concat(RB_R).concat(k3)).toString(CryptoJS.enc.Hex).slice(0, 16);

    return { ks1, ks2, ks3 };
  }
}
